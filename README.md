プログラムの概要について
serch_the_path(graph, start, current, path, all_paths)
引数：
graph: グラフを表す辞書。キーはノードで、値はそのノードから到達可能な隣接ノードのリスト。
start: 探索の開始ノード。探索の始点であり、戻ってきた場合に終了条件となる。
current: 現在探索中のノード。このノードから次に移動するノードを探索する。
path: 現在の探索経路。今までに訪問したノードを保持するリスト。
all_paths: 見つかったすべてのパスを保存するリスト。
処理の説明：
内部では隣のノードが存在する場合には、隣のノードをとってきたうえで、currentの隣のノードを入れて再帰的に関数を回しています。
終了条件としては、currentがスタート地点に戻ってきた場合、もしくは隣のノードが存在しなかった場合です。

find_all_paths(graph)
引数:
graph: グラフを表す辞書。キーはノードで、値はそのノードから到達可能な隣接ノードのリスト。
処理の説明:
graphのスタート地点をひとつずつとり、その値をserch_the_path関数に渡します。すべて探索が終わったら、all_pathsという名前で探索することが可能な値がリストとして帰ってきます。

find_longest_path(paths,weighted_graph)
引数:
paths: 探索された複数のパスのリスト。各パスは、ノードのリストとして表される。
weighted_graph: 重み付きグラフを表す辞書。キーはノードで、値は隣接するノードとそのエッジの重みがリスト形式で格納されている。各ノードはその隣接ノードと重みをリスト[隣接するノード,重み]として保持されている。
処理の説明:
weightを0に初期化してからpathsからルートをひとつずつ取得して、そのルート通った時の重みを変数weightに重さを足してそれが変数longestよりも大きい場合には、
最大パスのリストを初期化して、今のルートを追加する。またlongestをweightに更新する。
もし、longestとweightが一致していた場合には、長さ最大のリストが複数存在するということなので、最大パスのリストに今のルートを追加する。
その他変数について:
input_data:入力された始点、終点、距離のデータを保持する。 例：[[1, 2, 8.54], [2, 3, 3.11], [3, 1, 2.19], [3, 4, 4], [4, 1, 1.4]]
graph:無重みの辞書型のグラフ。ノードが隣接ノードのリストを保持しているが、重みの情報は含まれていない。例:{1: [2], 2: [3], 3: [1, 4], 4: [1]}
weighted_graph: 重み付きグラフ。各ノードが隣接ノードとそのエッジの重みをリスト形式で保持している。 例:{1: [[2, 8.54]], 2: [[3, 3.11]], 3: [[1, 2.19], [4, 4]], 4: [[1, 1.4]]}
distance: 最大経路を通った時の重み 例:17.05
result: 探索されたすべての経路の中で、最も長い経路のリスト 例:[[1, 2, 3, 4, 1], [2, 3, 4, 1, 2], [3, 4, 1, 2, 3], [4, 1, 2, 3, 4]]

困った点や工夫した点：
本当は重み付きのグラフのみを使って、ルートを探索しながら、同時に重みを計算して、ということがしたかったのですが、
始点と終点は同じになってもよいという点や、同じノードからルートがわかれている点から処理やリストの構造が複雑になってしまったので、
あきらめて重みなしのリストを使って探索可能なルートを先に全部出してからそのルートを使って、重みが最大になるルートを計算するという方法をとりました。
もし線路をぐるっと一周するようなルートがあった際には、どの点から始めても最大値が一緒になるので、最大値が同じであった場合には複数の値を保持するようにしました。
その際に計算を行う中で、小さな小数点の誤差が発生してしまっていたのでround関数を用いて丸め処理を行いました。
入力に関しては特に指定がなかったので、空の行が入力されるまで入力を受け付ける形としました。
